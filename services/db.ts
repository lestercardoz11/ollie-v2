import {
  ApplicationWithDetails,
  ChatWithMessages,
  MessageWithUser,
} from '@/types/join';
import {
  UserProfile,
  JobDescription,
  SupportingDocument,
  TailoredCV,
  Chat,
  Message,
  Skill,
} from '@/types/db';

import { createClient } from '@/utils/supabase/client';
import { QAResponse } from '@/types/ai';

// Define the expected structured output from the Gemini service for saving
interface GeneratedApplicationPackage {
  tailored_cv_data: Omit<TailoredCV, 'id' | 'user_id' | 'created_at'>;
  cover_letter_markdown: string;
  qa_responses: QAResponse[]; // Assuming this is still generated by Gemini
}

export const db = {
  /**
   * PROFILE OPERATIONS (Table: user_profiles) ðŸ‘¤
   */
  saveProfile: async (profile: Partial<UserProfile>): Promise<string> => {
    const supabase = createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    // Payload maps directly to snake_case DB fields
    const payload = {
      user_id: user.id,
      full_name: profile.full_name,
      email: profile.email,
      phone: profile.phone,
      location: profile.location,
      summary: profile.summary,
      resume_url: profile.resume_url,
      profile_picture_url: profile.profile_picture_url,
      additional_info: profile.additional_info,
      linkedin: profile.linkedin,
      portfolio: profile.portfolio,
      education: profile.education,
      experience: profile.experience,
      skills: profile.skills,
      achievements: profile.achievements,
    };

    const { data, error } = await supabase
      .from('user_profiles')
      .upsert(payload, { onConflict: 'user_id' })
      .select('id')
      .single();

    if (error) throw error;
    window.dispatchEvent(new Event('db-update'));
    return data.id;
  },

  getProfile: async (): Promise<UserProfile | null> => {
    const supabase = createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) return null;

    const { data, error } = await supabase
      .from('user_profiles')
      .select('*')
      .eq('user_id', user.id)
      .single();

    if (error && error.code !== 'PGRST116') {
      console.error('Error fetching profile:', error);
      return null;
    }
    if (!data) return null;

    // Direct mapping to UserProfile interface (fields are already snake_case)
    return data as UserProfile;
  },

  // --- SKILLS Master List Operations ---
  getSkills: async (): Promise<Skill[]> => {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('skills')
      .select('*')
      .order('name');
    if (error) {
      console.error('Error fetching skills:', error);
      return [];
    }
    return data as Skill[];
  },

  /**
   * DOCUMENT OPERATIONS (Table: supporting_documents) ðŸ“„
   */
  uploadDocument: async (file: File): Promise<SupportingDocument> => {
    const supabase = createClient();
    const bucketName = 'documents';

    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user?.id) {
      throw new Error('User ID is required');
    }

    // 1. Upload to Supabase Storage
    const fileExt = file.name.split('.').pop();
    const fileName = `${user.id}/${Date.now()}-${Math.random()
      .toString(36)
      .substring(7)}.${fileExt}`;

    const { error: uploadError } = await supabase.storage
      .from(bucketName)
      .upload(fileName, file, { upsert: false });
    if (uploadError) throw uploadError;

    // 2. Get Public URL
    const {
      data: { publicUrl },
    } = supabase.storage.from(bucketName).getPublicUrl(fileName);

    // 3. Save Metadata to Table
    const { data, error } = await supabase
      .from('supporting_documents')
      .insert({
        user_id: user.id,
        name: file.name,
        file_url: publicUrl,
        file_type: file.type,
      })
      .select()
      .single();

    if (error) throw error;

    return data as SupportingDocument;
  },

  getDocuments: async (): Promise<SupportingDocument[]> => {
    const supabase = createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const { data, error } = await supabase
      .from('supporting_documents')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (error) {
      console.error(error);
      return [];
    }
    return data as SupportingDocument[];
  },

  deleteDocument: async (documentId: string): Promise<void> => {
    const supabase = createClient();
    const bucketName = 'documents';

    // 1. Fetch document to get path
    const { data: doc, error: fetchError } = await supabase
      .from('supporting_documents')
      .select('file_url')
      .eq('id', documentId)
      .single();

    if (fetchError) throw fetchError;

    // 2. Delete from Storage
    if (doc && doc.file_url) {
      const urlParts = doc.file_url.split(`/${bucketName}/`);
      if (urlParts.length > 1) {
        const storagePath = decodeURIComponent(urlParts[1]);
        await supabase.storage.from(bucketName).remove([storagePath]);
      }
    }

    // 3. Delete Record
    const { error } = await supabase
      .from('supporting_documents')
      .delete()
      .eq('id', documentId);

    if (error) throw error;
  },

  /**
   * JOB OPERATIONS (Table: job_descriptions) ðŸ’¼
   */
  saveJob: async (
    job: Omit<JobDescription, 'id' | 'created_at'>
  ): Promise<string> => {
    const supabase = createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!job.title || !job.raw_text || !user?.id) {
      throw new Error('Job title, description, and user ID are required');
    }

    const { data, error } = await supabase
      .from('job_descriptions')
      .insert({
        user_id: user.id,
        title: job.title,
        company: job.company,
        raw_text: job.raw_text,
      })
      .select('id')
      .single();

    if (error) throw error;
    window.dispatchEvent(new Event('db-update'));
    return data.id;
  },

  getJobs: async (): Promise<JobDescription[]> => {
    const supabase = createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const getJobIds = async (userId: string) => {
      const { data, error } = await supabase
        .from('generated_applications')
        .select('job_id')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error(error);
        return [];
      }

      return data.map((item) => item.job_id);
    };

    const { data, error } = await supabase
      .from('job_descriptions')
      .select('*')
      .in('id', await getJobIds(user.id))
      .order('created_at', { ascending: false });

    if (error) {
      console.error(error);
      return [];
    }
    return data as JobDescription[];
  },

  getJobById: async (id: string): Promise<JobDescription | undefined> => {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('job_descriptions')
      .select('*')
      .eq('id', id)
      .single();

    if (error || !data) return undefined;

    return data as JobDescription;
  },

  /**
   * APPLICATION & CV OPERATIONS (Tables: tailored_cvs, generated_applications) âœ¨
   */
  saveTailoredCV: async (
    userId: string,
    cvData: Omit<TailoredCV, 'id' | 'user_id' | 'created_at'>
  ): Promise<string> => {
    const supabase = createClient();

    // Payload maps the nested JSON arrays to the JSONB columns
    const payload = {
      user_id: userId,
      summary: cvData.summary,
      experience: cvData.experience || [],
      education: cvData.education || [],
      achievements: cvData.achievements || [],
      skills: cvData.skills || [],
    };

    const { data, error } = await supabase
      .from('tailored_cvs')
      .insert(payload)
      .select('id')
      .single();

    if (error) throw error;
    return data.id;
  },

  saveApplicationPackage: async (
    jobId: string,
    profileId: string,
    cvId: string,
    chatId: string | null,
    generationOutput: Pick<GeneratedApplicationPackage, 'cover_letter_markdown'>
  ): Promise<string> => {
    const supabase = createClient();

    const payload = {
      job_id: jobId,
      profile_id: profileId,
      tailored_cv_id: cvId,
      cover_letter_markdown: generationOutput.cover_letter_markdown,
      chat_id: chatId,
    };

    const { data, error } = await supabase
      .from('generated_applications')
      .upsert(payload, { onConflict: 'job_id, profile_id' })
      .select('id')
      .single();

    if (error) throw error;
    window.dispatchEvent(new Event('db-update'));
    return data.id;
  },

  getApplicationWithDetails: async (
    jobId: string
  ): Promise<ApplicationWithDetails | undefined> => {
    const supabase = createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) return undefined;

    // Use foreign key relationship aliases to match ApplicationWithDetails interface
    const { data, error } = await supabase
      .from('generated_applications')
      .select(
        `
          *,
          job:job_id (*),
          tailored_cv:tailored_cv_id (*),
          chat:chat_id (*)
        `
      )
      .eq('job_id', jobId)
      .eq('user_id', user.id)
      .single();

    if (error && error.code !== 'PGRST116') {
      console.error('Error fetching application details:', error);
      return undefined;
    }
    if (!data) return undefined;

    return data as ApplicationWithDetails;
  },

  /**
   * CHAT OPERATIONS (Tables: chats, messages) ðŸ’¬
   */

  startNewChat: async (
    title: string | null = null,
    applicationId: string | null = null
  ): Promise<string> => {
    const supabase = createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const { data, error } = await supabase
      .from('chats')
      .insert({ user_id: user.id, title: title })
      .select('id')
      .single();

    if (error) throw error;
    const chatId = data.id;

    // Link the chat to an existing application if provided
    if (applicationId) {
      await db.linkChatToApplication(applicationId, chatId);
    }

    return chatId;
  },

  linkChatToApplication: async (
    applicationId: string,
    chatId: string
  ): Promise<void> => {
    const supabase = createClient();
    const { error } = await supabase
      .from('generated_applications')
      .update({ chat_id: chatId })
      .eq('id', applicationId);
    if (error) throw error;
  },

  getChats: async (userId: string): Promise<Chat[]> => {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('chats')
      .select('*')
      .eq('user_id', userId)
      .order('updated_at', { ascending: false });

    if (error) {
      console.error('Error fetching chats:', error);
      return [];
    }
    return data as Chat[];
  },

  getChatWithMessages: async (
    chatId: string
  ): Promise<ChatWithMessages | null> => {
    const supabase = createClient();

    const { data, error } = await supabase
      .from('chats')
      .select(
        `
        *,
        messages (*)
      `
      )
      .eq('id', chatId)
      .single();

    if (error && error.code !== 'PGRST116') {
      console.error('Error fetching chat with messages:', error);
      return null;
    }
    return data as ChatWithMessages | null;
  },

  addMessage: async (
    message: Omit<Message, 'id' | 'created_at'>
  ): Promise<string> => {
    const supabase = createClient();

    const { data, error } = await supabase
      .from('messages')
      .insert(message)
      .select('id')
      .single();

    if (error) throw error;
    const messageId = data.id;

    // Update the parent chat's updated_at timestamp
    await supabase
      .from('chats')
      .update({ updated_at: new Date().toISOString() })
      .eq('id', message.chat_id);

    return messageId;
  },

  getMessagesByChatId: async (chatId: string): Promise<MessageWithUser[]> => {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('messages')
      .select(
        `
        *,
        user:user_id (*)
      `
      )
      .eq('chat_id', chatId)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Error fetching messages with user details:', error);
      return [];
    }
    return data as MessageWithUser[];
  },
};
